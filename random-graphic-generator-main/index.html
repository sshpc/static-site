<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éšæœºå›¾å½¢æ•£åˆ—ç”Ÿæˆå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background-color: #f0f0f0;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 10px;
        }
        
        .header {
            text-align: center;
            padding: 10px;
            background-color: white;
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            font-size: 1.5rem;
            margin-bottom: 10px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        .timer-controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .timer-controls input, .timer-controls select {
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
        
        .info {
            text-align: center;
            margin-top: 10px;
            color: #666;
            font-size: 12px;
        }
        
        .status {
            text-align: center;
            margin: 5px 0;
            font-weight: bold;
            color: #333;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¨ éšæœºå›¾å½¢æ•£åˆ—ç”Ÿæˆå™¨</h1>
            
            <div class="controls">
                <button id="generateBtn">ç”Ÿæˆæ–°å›¾å½¢</button>
                <button id="downloadBtn">ä¸‹è½½å›¾åƒ</button>
                <button id="changeColorBtn">æ¢é¢œè‰²æ–¹æ¡ˆ</button>
                <button id="changeShapeBtn">æ¢å›¾å½¢ç±»å‹</button>
            </div>
            
            <div class="timer-controls">
                <label>å®šæ—¶ç”Ÿæˆé—´éš”(ç§’):</label>
                <input type="number" id="intervalInput" min="0.1" max="10" value="0.1" step="0.1">
                <select id="autoModeSelect">
                    <option value="shapes">ä»…åˆ‡æ¢å›¾å½¢ç±»å‹</option>
                    <option value="colors">ä»…åˆ‡æ¢é¢œè‰²æ–¹æ¡ˆ</option>
                    <option value="all">éšæœºåˆ‡æ¢å›¾å½¢å’Œé¢œè‰²</option>
                    <option value="none">å…³é—­è‡ªåŠ¨æ¨¡å¼</option>
                </select>
                <button id="startTimerBtn">å¼€å§‹è‡ªåŠ¨</button>
                <button id="stopTimerBtn">åœæ­¢è‡ªåŠ¨</button>
            </div>
            
            <div class="status" id="statusText">è‡ªåŠ¨æ¨¡å¼: å·²åœæ­¢</div>
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="info">
            <p>ç‚¹å‡»"ç”Ÿæˆæ–°å›¾å½¢"åˆ›å»ºéšæœºå›¾å½¢ | æ¯æ¬¡ç”Ÿæˆéƒ½æœ‰ä¸åŒçš„å½¢çŠ¶ã€é¢œè‰²å’Œä½ç½®</p>
            <p>ä½¿ç”¨å®šæ—¶å™¨åŠŸèƒ½å¯å®ç°è‡ªåŠ¨åˆ‡æ¢å›¾å½¢ | å¯é€‰æ‹©ä¸åŒçš„è‡ªåŠ¨æ¨¡å¼</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const generateBtn = document.getElementById('generateBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const changeColorBtn = document.getElementById('changeColorBtn');
        const changeShapeBtn = document.getElementById('changeShapeBtn');
        const intervalInput = document.getElementById('intervalInput');
        const autoModeSelect = document.getElementById('autoModeSelect');
        const startTimerBtn = document.getElementById('startTimerBtn');
        const stopTimerBtn = document.getElementById('stopTimerBtn');
        const statusText = document.getElementById('statusText');
        
        // é¢œè‰²æ–¹æ¡ˆæ•°ç»„
        const colorSchemes = [
            ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFBE0B', '#FB5607'],
            ['#8338EC', '#3A86FF', '#329F5B', '#FF006E', '#8AC926'],
            ['#F15BB5', '#FEE440', '#00BBF9', '#00F5D4', '#9B5DE5'],
            ['#EF233C', '#FFD60A', '#80FFDB', '#0077B6', '#03045E'],
            ['#9D4EDD', '#FF9E00', '#FF5400', '#7209B7', '#F15BB5']
        ];
        
        // å½“å‰ä½¿ç”¨çš„é¢œè‰²æ–¹æ¡ˆ
        let currentColorScheme = 0;
        
        // å›¾å½¢ç±»å‹
        const shapeTypes = ['circle', 'rectangle', 'triangle', 'star', 'polygon'];
        let currentShapeType = 0;
        
        // å®šæ—¶å™¨å˜é‡
        let timerInterval = null;
        
        // åˆå§‹åŒ–ç”»å¸ƒå°ºå¯¸
        function initCanvas() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width - 20; // ç•™å‡ºä¸€äº›è¾¹è·
            canvas.height = rect.height - 20; // ç•™å‡ºä¸€äº›è¾¹è·
            drawRandomShapes();
        }
        
        // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è°ƒæ•´ç”»å¸ƒ
        window.addEventListener('resize', initCanvas);
        
        // ç”Ÿæˆéšæœºé¢œè‰²
        function getRandomColor() {
            const scheme = colorSchemes[currentColorScheme];
            return scheme[Math.floor(Math.random() * scheme.length)];
        }
        
        // ç”Ÿæˆéšæœºæ•´æ•°
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // ç”Ÿæˆéšæœºæµ®ç‚¹æ•°
        function randomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }
        
        // ç»˜åˆ¶åœ†å½¢
        function drawCircle(x, y, radius, color) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // ç»˜åˆ¶çŸ©å½¢
        function drawRectangle(x, y, width, height, color) {
            ctx.beginPath();
            ctx.rect(x, y, width, height);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // ç»˜åˆ¶ä¸‰è§’å½¢
        function drawTriangle(x, y, size, color) {
            ctx.beginPath();
            ctx.moveTo(x, y - size/2);
            ctx.lineTo(x + size/2, y + size/2);
            ctx.lineTo(x - size/2, y + size/2);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // ç»˜åˆ¶æ˜Ÿå½¢
        function drawStar(cx, cy, spikes, outerRadius, innerRadius, color) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            let step = Math.PI / spikes;
            
            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;
                
                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // ç»˜åˆ¶å¤šè¾¹å½¢
        function drawPolygon(x, y, sides, radius, color) {
            ctx.beginPath();
            const angle = (Math.PI * 2) / sides;
            
            for (let i = 0; i < sides; i++) {
                const px = x + radius * Math.cos(i * angle);
                const py = y + radius * Math.sin(i * angle);
                
                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // ç»˜åˆ¶éšæœºå›¾å½¢
        function drawRandomShapes() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // è®¾ç½®èƒŒæ™¯
            const bgColor = '#F8F9FA';
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // æ ¹æ®ç”»å¸ƒå°ºå¯¸è°ƒæ•´å›¾å½¢æ•°é‡å’Œå¤§å°
            const shapeCount = Math.floor((canvas.width * canvas.height) / 8000); // æ ¹æ®ç”»å¸ƒé¢ç§¯è°ƒæ•´å›¾å½¢æ•°é‡
            const maxShapeSize = Math.min(canvas.width, canvas.height) / 10; // æœ€å¤§å›¾å½¢å°ºå¯¸
            
            for (let i = 0; i < shapeCount; i++) {
                // éšæœºä½ç½®
                const x = randomInt(20, canvas.width - 20);
                const y = randomInt(20, canvas.height - 20);
                
                // éšæœºå¤§å°ï¼ˆæ ¹æ®ç”»å¸ƒå°ºå¯¸è‡ªé€‚åº”ï¼‰
                const size = randomInt(10, maxShapeSize);
                
                // éšæœºé¢œè‰²
                const color = getRandomColor();
                
                // æ ¹æ®å½“å‰å›¾å½¢ç±»å‹ç»˜åˆ¶
                switch (shapeTypes[currentShapeType]) {
                    case 'circle':
                        drawCircle(x, y, size/2, color);
                        break;
                    case 'rectangle':
                        drawRectangle(x - size/2, y - size/2, size, size, color);
                        break;
                    case 'triangle':
                        drawTriangle(x, y, size, color);
                        break;
                    case 'star':
                        drawStar(x, y, randomInt(5, 8), size/2, size/4, color);
                        break;
                    case 'polygon':
                        drawPolygon(x, y, randomInt(3, 8), size/2, color);
                        break;
                }
            }
        }
        
        // ä¸‹è½½å›¾åƒ
        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'random-shapes-' + new Date().getTime() + '.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
        
        // å¼€å§‹è‡ªåŠ¨æ¨¡å¼
        function startAutoMode() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            const interval = parseFloat(intervalInput.value) * 1000;
            const mode = autoModeSelect.value;
            
            timerInterval = setInterval(() => {
                if (mode === 'shapes') {
                    currentShapeType = (currentShapeType + 1) % shapeTypes.length;
                } else if (mode === 'colors') {
                    currentColorScheme = (currentColorScheme + 1) % colorSchemes.length;
                } else if (mode === 'all') {
                    // éšæœºé€‰æ‹©æ˜¯åˆ‡æ¢å›¾å½¢è¿˜æ˜¯é¢œè‰²
                    if (Math.random() > 0.5) {
                        currentShapeType = (currentShapeType + 1) % shapeTypes.length;
                    } else {
                        currentColorScheme = (currentColorScheme + 1) % colorSchemes.length;
                    }
                }
                drawRandomShapes();
            }, interval);
            
            statusText.textContent = `è‡ªåŠ¨æ¨¡å¼: è¿è¡Œä¸­ (é—´éš”: ${intervalInput.value}ç§’, æ¨¡å¼: ${autoModeSelect.options[autoModeSelect.selectedIndex].text})`;
        }
        
        // åœæ­¢è‡ªåŠ¨æ¨¡å¼
        function stopAutoMode() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            statusText.textContent = 'è‡ªåŠ¨æ¨¡å¼: å·²åœæ­¢';
        }
        
        // äº‹ä»¶ç›‘å¬å™¨
        generateBtn.addEventListener('click', drawRandomShapes);
        downloadBtn.addEventListener('click', downloadImage);
        
        changeColorBtn.addEventListener('click', () => {
            currentColorScheme = (currentColorScheme + 1) % colorSchemes.length;
            drawRandomShapes();
        });
        
        changeShapeBtn.addEventListener('click', () => {
            currentShapeType = (currentShapeType + 1) % shapeTypes.length;
            drawRandomShapes();
        });
        
        startTimerBtn.addEventListener('click', startAutoMode);
        stopTimerBtn.addEventListener('click', stopAutoMode);
        
        // åˆå§‹åŒ–ç”»å¸ƒå’Œç»˜åˆ¶
        initCanvas();
    </script>
</body>
</html>
